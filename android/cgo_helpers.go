// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Tue, 17 May 2016 04:44:23 MSK.
// By http://git.io/cgogen. DO NOT EDIT.

package android

/*
#cgo LDFLAGS: -landroid
#include <android/api-level.h>
#include <android/asset_manager.h>
#include <android/asset_manager_jni.h>
#include <android/input.h>
#include <android/keycodes.h>
#include <android/log.h>
#include <android/looper.h>
#include <android/native_activity.h>
#include <android/native_window.h>
#include <android/native_window_jni.h>
#include <android/obb.h>
#include <android/rect.h>
#include <android/storage_manager.h>
#include <android/tts.h>
#include <android/window.h>
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocJNINativeMethodMemory allocates memory for type C.JNINativeMethod in C.
// The caller is responsible for freeing the this memory via C.free.
func allocJNINativeMethodMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfJNINativeMethodValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfJNINativeMethodValue = unsafe.Sizeof([1]C.JNINativeMethod{})

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

type stringHeader struct {
	Data uintptr
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len))
}

// Ref returns a reference.
func (x *JNINativeMethod) Ref() *C.JNINativeMethod {
	if x == nil {
		return nil
	}
	return x.refd6f16615
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *JNINativeMethod) Free() {
	if x != nil && x.allocsd6f16615 != nil {
		x.allocsd6f16615.(*cgoAllocMap).Free()
		x.refd6f16615 = nil
	}
}

// NewJNINativeMethodRef initialises a new struct holding the reference to the originaitng C struct.
func NewJNINativeMethodRef(ref *C.JNINativeMethod) *JNINativeMethod {
	if ref == nil {
		return nil
	}
	obj := new(JNINativeMethod)
	obj.refd6f16615 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *JNINativeMethod) PassRef() (*C.JNINativeMethod, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd6f16615 != nil {
		return x.refd6f16615, nil
	}
	memd6f16615 := allocJNINativeMethodMemory(1)
	refd6f16615 := (*C.JNINativeMethod)(memd6f16615)
	allocsd6f16615 := new(cgoAllocMap)
	var cname_allocs *cgoAllocMap
	refd6f16615.name, cname_allocs = unpackPCharString(x.name)
	allocsd6f16615.Borrow(cname_allocs)

	var csignature_allocs *cgoAllocMap
	refd6f16615.signature, csignature_allocs = unpackPCharString(x.signature)
	allocsd6f16615.Borrow(csignature_allocs)

	var cfnPtr_allocs *cgoAllocMap
	refd6f16615.fnPtr, cfnPtr_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.fnPtr)), cgoAllocsUnknown
	allocsd6f16615.Borrow(cfnPtr_allocs)

	x.refd6f16615 = refd6f16615
	x.allocsd6f16615 = allocsd6f16615
	return refd6f16615, allocsd6f16615

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *JNINativeMethod) PassValue() (C.JNINativeMethod, *cgoAllocMap) {
	if x == nil {
		x = NewJNINativeMethodRef(nil)
	} else if x.refd6f16615 != nil {
		return *x.refd6f16615, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *JNINativeMethod) Deref() {
	if x.refd6f16615 == nil {
		return
	}
	x.name = packPCharString(x.refd6f16615.name)
	x.signature = packPCharString(x.refd6f16615.signature)
	x.fnPtr = (unsafe.Pointer)(unsafe.Pointer(x.refd6f16615.fnPtr))
}

// allocJavaVMOptionMemory allocates memory for type C.JavaVMOption in C.
// The caller is responsible for freeing the this memory via C.free.
func allocJavaVMOptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfJavaVMOptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfJavaVMOptionValue = unsafe.Sizeof([1]C.JavaVMOption{})

// Ref returns a reference.
func (x *JavaVMOption) Ref() *C.JavaVMOption {
	if x == nil {
		return nil
	}
	return x.refdae9fae3
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *JavaVMOption) Free() {
	if x != nil && x.allocsdae9fae3 != nil {
		x.allocsdae9fae3.(*cgoAllocMap).Free()
		x.refdae9fae3 = nil
	}
}

// NewJavaVMOptionRef initialises a new struct holding the reference to the originaitng C struct.
func NewJavaVMOptionRef(ref *C.JavaVMOption) *JavaVMOption {
	if ref == nil {
		return nil
	}
	obj := new(JavaVMOption)
	obj.refdae9fae3 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *JavaVMOption) PassRef() (*C.JavaVMOption, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdae9fae3 != nil {
		return x.refdae9fae3, nil
	}
	memdae9fae3 := allocJavaVMOptionMemory(1)
	refdae9fae3 := (*C.JavaVMOption)(memdae9fae3)
	allocsdae9fae3 := new(cgoAllocMap)
	var coptionString_allocs *cgoAllocMap
	refdae9fae3.optionString, coptionString_allocs = unpackPCharString(x.optionString)
	allocsdae9fae3.Borrow(coptionString_allocs)

	var cextraInfo_allocs *cgoAllocMap
	refdae9fae3.extraInfo, cextraInfo_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.extraInfo)), cgoAllocsUnknown
	allocsdae9fae3.Borrow(cextraInfo_allocs)

	x.refdae9fae3 = refdae9fae3
	x.allocsdae9fae3 = allocsdae9fae3
	return refdae9fae3, allocsdae9fae3

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *JavaVMOption) PassValue() (C.JavaVMOption, *cgoAllocMap) {
	if x == nil {
		x = NewJavaVMOptionRef(nil)
	} else if x.refdae9fae3 != nil {
		return *x.refdae9fae3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *JavaVMOption) Deref() {
	if x.refdae9fae3 == nil {
		return
	}
	x.optionString = packPCharString(x.refdae9fae3.optionString)
	x.extraInfo = (unsafe.Pointer)(unsafe.Pointer(x.refdae9fae3.extraInfo))
}

// allocJavaVMInitArgsMemory allocates memory for type C.JavaVMInitArgs in C.
// The caller is responsible for freeing the this memory via C.free.
func allocJavaVMInitArgsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfJavaVMInitArgsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfJavaVMInitArgsValue = unsafe.Sizeof([1]C.JavaVMInitArgs{})

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSJavaVMOption transforms a sliced Go data structure into plain C format.
func unpackSJavaVMOption(x []JavaVMOption) (unpacked *C.JavaVMOption, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.JavaVMOption) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocJavaVMOptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.JavaVMOption)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.JavaVMOption)(unsafe.Pointer(h.Data))
	return
}

// packSJavaVMOption reads sliced Go data structure out from plain C format.
func packSJavaVMOption(v []JavaVMOption, ptr0 *C.JavaVMOption) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfJavaVMOptionValue]C.JavaVMOption)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewJavaVMOptionRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *JavaVMInitArgs) Ref() *C.JavaVMInitArgs {
	if x == nil {
		return nil
	}
	return x.ref93580a6
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *JavaVMInitArgs) Free() {
	if x != nil && x.allocs93580a6 != nil {
		x.allocs93580a6.(*cgoAllocMap).Free()
		x.ref93580a6 = nil
	}
}

// NewJavaVMInitArgsRef initialises a new struct holding the reference to the originaitng C struct.
func NewJavaVMInitArgsRef(ref *C.JavaVMInitArgs) *JavaVMInitArgs {
	if ref == nil {
		return nil
	}
	obj := new(JavaVMInitArgs)
	obj.ref93580a6 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *JavaVMInitArgs) PassRef() (*C.JavaVMInitArgs, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref93580a6 != nil {
		return x.ref93580a6, nil
	}
	mem93580a6 := allocJavaVMInitArgsMemory(1)
	ref93580a6 := (*C.JavaVMInitArgs)(mem93580a6)
	allocs93580a6 := new(cgoAllocMap)
	var cversion_allocs *cgoAllocMap
	ref93580a6.version, cversion_allocs = (C.jint)(x.version), cgoAllocsUnknown
	allocs93580a6.Borrow(cversion_allocs)

	var cnOptions_allocs *cgoAllocMap
	ref93580a6.nOptions, cnOptions_allocs = (C.jint)(x.nOptions), cgoAllocsUnknown
	allocs93580a6.Borrow(cnOptions_allocs)

	var coptions_allocs *cgoAllocMap
	ref93580a6.options, coptions_allocs = unpackSJavaVMOption(x.options)
	allocs93580a6.Borrow(coptions_allocs)

	var cignoreUnrecognized_allocs *cgoAllocMap
	ref93580a6.ignoreUnrecognized, cignoreUnrecognized_allocs = (C.jboolean)(x.ignoreUnrecognized), cgoAllocsUnknown
	allocs93580a6.Borrow(cignoreUnrecognized_allocs)

	x.ref93580a6 = ref93580a6
	x.allocs93580a6 = allocs93580a6
	return ref93580a6, allocs93580a6

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *JavaVMInitArgs) PassValue() (C.JavaVMInitArgs, *cgoAllocMap) {
	if x == nil {
		x = NewJavaVMInitArgsRef(nil)
	} else if x.ref93580a6 != nil {
		return *x.ref93580a6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *JavaVMInitArgs) Deref() {
	if x.ref93580a6 == nil {
		return
	}
	x.version = (int32)(x.ref93580a6.version)
	x.nOptions = (int32)(x.ref93580a6.nOptions)
	packSJavaVMOption(x.options, x.ref93580a6.options)
	x.ignoreUnrecognized = (byte)(x.ref93580a6.ignoreUnrecognized)
}

// PassRef returns a reference.
func (x LooperCallbackFunc) PassRef() (ref *C.ALooper_callbackFunc, allocs *cgoAllocMap) {
	if looperCallbackFunc7E6B484CFunc == nil {
		looperCallbackFunc7E6B484CFunc = x
	}
	return (*C.ALooper_callbackFunc)(C.ALooper_callbackFunc_7e6b484c), nil
}

// PassValue returns a value.
func (x LooperCallbackFunc) PassValue() (ref C.ALooper_callbackFunc, allocs *cgoAllocMap) {
	if looperCallbackFunc7E6B484CFunc == nil {
		looperCallbackFunc7E6B484CFunc = x
	}
	return (C.ALooper_callbackFunc)(C.ALooper_callbackFunc_7e6b484c), nil
}

//export looperCallbackFunc7E6B484C
func looperCallbackFunc7E6B484C(cfd C.int, cevents C.int, cdata unsafe.Pointer) C.int {
	if looperCallbackFunc7E6B484CFunc != nil {
		fd7e6b484c := (int32)(cfd)
		events7e6b484c := (int32)(cevents)
		data7e6b484c := (unsafe.Pointer)(unsafe.Pointer(cdata))
		ret7e6b484c := looperCallbackFunc7E6B484CFunc(fd7e6b484c, events7e6b484c, data7e6b484c)
		ret, _ := (C.int)(ret7e6b484c), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var looperCallbackFunc7E6B484CFunc LooperCallbackFunc

// PassRef returns a reference.
func (x NativeActivityCreateFunc) PassRef() (ref *C.ANativeActivity_createFunc, allocs *cgoAllocMap) {
	if nativeActivityCreateFunc76DCE4Func == nil {
		nativeActivityCreateFunc76DCE4Func = x
	}
	return (*C.ANativeActivity_createFunc)(C.ANativeActivity_createFunc_76dce4), nil
}

//export nativeActivityCreateFunc76DCE4
func nativeActivityCreateFunc76DCE4(cactivity *C.ANativeActivity, csavedState unsafe.Pointer, csavedStateSize C.size_t) {
	if nativeActivityCreateFunc76DCE4Func != nil {
		activity76dce4 := (*NativeActivity)(unsafe.Pointer(cactivity))
		savedState76dce4 := (unsafe.Pointer)(unsafe.Pointer(csavedState))
		savedStateSize76dce4 := (uint32)(csavedStateSize)
		nativeActivityCreateFunc76DCE4Func(activity76dce4, savedState76dce4, savedStateSize76dce4)
	}
	panic("callback func has not been set (race?)")
}

var nativeActivityCreateFunc76DCE4Func NativeActivityCreateFunc

// allocNativeWindowBufferMemory allocates memory for type C.ANativeWindow_Buffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocNativeWindowBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfNativeWindowBufferValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfNativeWindowBufferValue = unsafe.Sizeof([1]C.ANativeWindow_Buffer{})

// Ref returns a reference.
func (x *NativeWindowBuffer) Ref() *C.ANativeWindow_Buffer {
	if x == nil {
		return nil
	}
	return x.ref3db2646c
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *NativeWindowBuffer) Free() {
	if x != nil && x.allocs3db2646c != nil {
		x.allocs3db2646c.(*cgoAllocMap).Free()
		x.ref3db2646c = nil
	}
}

// NewNativeWindowBufferRef initialises a new struct holding the reference to the originaitng C struct.
func NewNativeWindowBufferRef(ref *C.ANativeWindow_Buffer) *NativeWindowBuffer {
	if ref == nil {
		return nil
	}
	obj := new(NativeWindowBuffer)
	obj.ref3db2646c = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *NativeWindowBuffer) PassRef() (*C.ANativeWindow_Buffer, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3db2646c != nil {
		return x.ref3db2646c, nil
	}
	mem3db2646c := allocNativeWindowBufferMemory(1)
	ref3db2646c := (*C.ANativeWindow_Buffer)(mem3db2646c)
	allocs3db2646c := new(cgoAllocMap)
	var cwidth_allocs *cgoAllocMap
	ref3db2646c.width, cwidth_allocs = (C.int32_t)(x.width), cgoAllocsUnknown
	allocs3db2646c.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref3db2646c.height, cheight_allocs = (C.int32_t)(x.height), cgoAllocsUnknown
	allocs3db2646c.Borrow(cheight_allocs)

	var cstride_allocs *cgoAllocMap
	ref3db2646c.stride, cstride_allocs = (C.int32_t)(x.stride), cgoAllocsUnknown
	allocs3db2646c.Borrow(cstride_allocs)

	var cformat_allocs *cgoAllocMap
	ref3db2646c.format, cformat_allocs = (C.int32_t)(x.format), cgoAllocsUnknown
	allocs3db2646c.Borrow(cformat_allocs)

	var cbits_allocs *cgoAllocMap
	ref3db2646c.bits, cbits_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.bits)), cgoAllocsUnknown
	allocs3db2646c.Borrow(cbits_allocs)

	var creserved_allocs *cgoAllocMap
	ref3db2646c.reserved, creserved_allocs = *(*[6]C.uint32_t)(unsafe.Pointer(&x.reserved)), cgoAllocsUnknown
	allocs3db2646c.Borrow(creserved_allocs)

	x.ref3db2646c = ref3db2646c
	x.allocs3db2646c = allocs3db2646c
	return ref3db2646c, allocs3db2646c

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *NativeWindowBuffer) PassValue() (C.ANativeWindow_Buffer, *cgoAllocMap) {
	if x == nil {
		x = NewNativeWindowBufferRef(nil)
	} else if x.ref3db2646c != nil {
		return *x.ref3db2646c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *NativeWindowBuffer) Deref() {
	if x.ref3db2646c == nil {
		return
	}
	x.width = (int32)(x.ref3db2646c.width)
	x.height = (int32)(x.ref3db2646c.height)
	x.stride = (int32)(x.ref3db2646c.stride)
	x.format = (int32)(x.ref3db2646c.format)
	x.bits = (unsafe.Pointer)(unsafe.Pointer(x.ref3db2646c.bits))
	x.reserved = *(*[6]uint32)(unsafe.Pointer(&x.ref3db2646c.reserved))
}

// allocRectMemory allocates memory for type C.ARect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRectValue = unsafe.Sizeof([1]C.ARect{})

// Ref returns a reference.
func (x *Rect) Ref() *C.ARect {
	if x == nil {
		return nil
	}
	return x.ref9511c547
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Rect) Free() {
	if x != nil && x.allocs9511c547 != nil {
		x.allocs9511c547.(*cgoAllocMap).Free()
		x.ref9511c547 = nil
	}
}

// NewRectRef initialises a new struct holding the reference to the originaitng C struct.
func NewRectRef(ref *C.ARect) *Rect {
	if ref == nil {
		return nil
	}
	obj := new(Rect)
	obj.ref9511c547 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Rect) PassRef() (*C.ARect, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9511c547 != nil {
		return x.ref9511c547, nil
	}
	mem9511c547 := allocRectMemory(1)
	ref9511c547 := (*C.ARect)(mem9511c547)
	allocs9511c547 := new(cgoAllocMap)
	var cleft_allocs *cgoAllocMap
	ref9511c547.left, cleft_allocs = (C.int32_t)(x.left), cgoAllocsUnknown
	allocs9511c547.Borrow(cleft_allocs)

	var ctop_allocs *cgoAllocMap
	ref9511c547.top, ctop_allocs = (C.int32_t)(x.top), cgoAllocsUnknown
	allocs9511c547.Borrow(ctop_allocs)

	var cright_allocs *cgoAllocMap
	ref9511c547.right, cright_allocs = (C.int32_t)(x.right), cgoAllocsUnknown
	allocs9511c547.Borrow(cright_allocs)

	var cbottom_allocs *cgoAllocMap
	ref9511c547.bottom, cbottom_allocs = (C.int32_t)(x.bottom), cgoAllocsUnknown
	allocs9511c547.Borrow(cbottom_allocs)

	x.ref9511c547 = ref9511c547
	x.allocs9511c547 = allocs9511c547
	return ref9511c547, allocs9511c547

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *Rect) PassValue() (C.ARect, *cgoAllocMap) {
	if x == nil {
		x = NewRectRef(nil)
	} else if x.ref9511c547 != nil {
		return *x.ref9511c547, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Rect) Deref() {
	if x.ref9511c547 == nil {
		return
	}
	x.left = (int32)(x.ref9511c547.left)
	x.top = (int32)(x.ref9511c547.top)
	x.right = (int32)(x.ref9511c547.right)
	x.bottom = (int32)(x.ref9511c547.bottom)
}

// PassRef returns a reference.
func (x StorageManagerObbCallbackFunc) PassRef() (ref *C.AStorageManager_obbCallbackFunc, allocs *cgoAllocMap) {
	if storageManagerObbCallbackFuncE8B15C3EFunc == nil {
		storageManagerObbCallbackFuncE8B15C3EFunc = x
	}
	return (*C.AStorageManager_obbCallbackFunc)(C.AStorageManager_obbCallbackFunc_e8b15c3e), nil
}

// PassValue returns a value.
func (x StorageManagerObbCallbackFunc) PassValue() (ref C.AStorageManager_obbCallbackFunc, allocs *cgoAllocMap) {
	if storageManagerObbCallbackFuncE8B15C3EFunc == nil {
		storageManagerObbCallbackFuncE8B15C3EFunc = x
	}
	return (C.AStorageManager_obbCallbackFunc)(C.AStorageManager_obbCallbackFunc_e8b15c3e), nil
}

//export storageManagerObbCallbackFuncE8B15C3E
func storageManagerObbCallbackFuncE8B15C3E(cfilename *C.char, cstate C.int32_t, cdata unsafe.Pointer) {
	if storageManagerObbCallbackFuncE8B15C3EFunc != nil {
		filenamee8b15c3e := packPCharString(cfilename)
		statee8b15c3e := (int32)(cstate)
		datae8b15c3e := (unsafe.Pointer)(unsafe.Pointer(cdata))
		storageManagerObbCallbackFuncE8B15C3EFunc(filenamee8b15c3e, statee8b15c3e, datae8b15c3e)
	}
	panic("callback func has not been set (race?)")
}

var storageManagerObbCallbackFuncE8B15C3EFunc StorageManagerObbCallbackFunc
