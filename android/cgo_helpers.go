// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Sun, 22 May 2016 01:51:23 MSK.
// By http://git.io/cgogen. DO NOT EDIT.

package android

/*
#cgo LDFLAGS: -landroid
#include <android/api-level.h>
#include <android/asset_manager.h>
#include <android/asset_manager_jni.h>
#include <android/configuration.h>
#include <android/input.h>
#include <android/keycodes.h>
#include <android/log.h>
#include <android/looper.h>
#include <android/native_activity.h>
#include <android/native_window.h>
#include <android/native_window_jni.h>
#include <android/obb.h>
#include <android/rect.h>
#include <android/storage_manager.h>
#include <android/tts.h>
#include <android/window.h>
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"sync"
	"unsafe"
)

// Ref returns a reference.
func (x *AssetManager) Ref() *C.AAssetManager {
	if x == nil {
		return nil
	}
	return (*C.AAssetManager)(unsafe.Pointer(x))
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *AssetManager) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewAssetManagerRef initialises a new struct.
func NewAssetManagerRef(ref *C.AAssetManager) *AssetManager {
	return (*AssetManager)(unsafe.Pointer(ref))
}

// PassRef returns a reference and creates new object if no refernce yet.
func (x *AssetManager) PassRef() *C.AAssetManager {
	if x == nil {
		x = new(AssetManager)
	}
	return (*C.AAssetManager)(unsafe.Pointer(x))
}

// Ref returns a reference.
func (x *AssetDir) Ref() *C.AAssetDir {
	if x == nil {
		return nil
	}
	return (*C.AAssetDir)(unsafe.Pointer(x))
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *AssetDir) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewAssetDirRef initialises a new struct.
func NewAssetDirRef(ref *C.AAssetDir) *AssetDir {
	return (*AssetDir)(unsafe.Pointer(ref))
}

// PassRef returns a reference and creates new object if no refernce yet.
func (x *AssetDir) PassRef() *C.AAssetDir {
	if x == nil {
		x = new(AssetDir)
	}
	return (*C.AAssetDir)(unsafe.Pointer(x))
}

// Ref returns a reference.
func (x *Asset) Ref() *C.AAsset {
	if x == nil {
		return nil
	}
	return (*C.AAsset)(unsafe.Pointer(x))
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Asset) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewAssetRef initialises a new struct.
func NewAssetRef(ref *C.AAsset) *Asset {
	return (*Asset)(unsafe.Pointer(ref))
}

// PassRef returns a reference and creates new object if no refernce yet.
func (x *Asset) PassRef() *C.AAsset {
	if x == nil {
		x = new(Asset)
	}
	return (*C.AAsset)(unsafe.Pointer(x))
}

// Ref returns a reference.
func (x *JNINativeMethod) Ref() *C.JNINativeMethod {
	if x == nil {
		return nil
	}
	return (*C.JNINativeMethod)(unsafe.Pointer(x))
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *JNINativeMethod) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewJNINativeMethodRef initialises a new struct.
func NewJNINativeMethodRef(ref *C.JNINativeMethod) *JNINativeMethod {
	return (*JNINativeMethod)(unsafe.Pointer(ref))
}

// PassRef returns a reference and creates new object if no refernce yet.
func (x *JNINativeMethod) PassRef() *C.JNINativeMethod {
	if x == nil {
		x = new(JNINativeMethod)
	}
	return (*C.JNINativeMethod)(unsafe.Pointer(x))
}

// Ref returns a reference.
func (x *JavaVMAttachArgs) Ref() *C.JavaVMAttachArgs {
	if x == nil {
		return nil
	}
	return (*C.JavaVMAttachArgs)(unsafe.Pointer(x))
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *JavaVMAttachArgs) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewJavaVMAttachArgsRef initialises a new struct.
func NewJavaVMAttachArgsRef(ref *C.JavaVMAttachArgs) *JavaVMAttachArgs {
	return (*JavaVMAttachArgs)(unsafe.Pointer(ref))
}

// PassRef returns a reference and creates new object if no refernce yet.
func (x *JavaVMAttachArgs) PassRef() *C.JavaVMAttachArgs {
	if x == nil {
		x = new(JavaVMAttachArgs)
	}
	return (*C.JavaVMAttachArgs)(unsafe.Pointer(x))
}

// Ref returns a reference.
func (x *JavaVMOption) Ref() *C.JavaVMOption {
	if x == nil {
		return nil
	}
	return (*C.JavaVMOption)(unsafe.Pointer(x))
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *JavaVMOption) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewJavaVMOptionRef initialises a new struct.
func NewJavaVMOptionRef(ref *C.JavaVMOption) *JavaVMOption {
	return (*JavaVMOption)(unsafe.Pointer(ref))
}

// PassRef returns a reference and creates new object if no refernce yet.
func (x *JavaVMOption) PassRef() *C.JavaVMOption {
	if x == nil {
		x = new(JavaVMOption)
	}
	return (*C.JavaVMOption)(unsafe.Pointer(x))
}

// Ref returns a reference.
func (x *JavaVMInitArgs) Ref() *C.JavaVMInitArgs {
	if x == nil {
		return nil
	}
	return (*C.JavaVMInitArgs)(unsafe.Pointer(x))
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *JavaVMInitArgs) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewJavaVMInitArgsRef initialises a new struct.
func NewJavaVMInitArgsRef(ref *C.JavaVMInitArgs) *JavaVMInitArgs {
	return (*JavaVMInitArgs)(unsafe.Pointer(ref))
}

// PassRef returns a reference and creates new object if no refernce yet.
func (x *JavaVMInitArgs) PassRef() *C.JavaVMInitArgs {
	if x == nil {
		x = new(JavaVMInitArgs)
	}
	return (*C.JavaVMInitArgs)(unsafe.Pointer(x))
}

// Ref returns a reference.
func (x *Configuration) Ref() *C.AConfiguration {
	if x == nil {
		return nil
	}
	return (*C.AConfiguration)(unsafe.Pointer(x))
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Configuration) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewConfigurationRef initialises a new struct.
func NewConfigurationRef(ref *C.AConfiguration) *Configuration {
	return (*Configuration)(unsafe.Pointer(ref))
}

// PassRef returns a reference and creates new object if no refernce yet.
func (x *Configuration) PassRef() *C.AConfiguration {
	if x == nil {
		x = new(Configuration)
	}
	return (*C.AConfiguration)(unsafe.Pointer(x))
}

// Ref returns a reference.
func (x *Looper) Ref() *C.ALooper {
	if x == nil {
		return nil
	}
	return (*C.ALooper)(unsafe.Pointer(x))
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Looper) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewLooperRef initialises a new struct.
func NewLooperRef(ref *C.ALooper) *Looper {
	return (*Looper)(unsafe.Pointer(ref))
}

// PassRef returns a reference and creates new object if no refernce yet.
func (x *Looper) PassRef() *C.ALooper {
	if x == nil {
		x = new(Looper)
	}
	return (*C.ALooper)(unsafe.Pointer(x))
}

// PassRef returns a reference.
func (x LooperCallbackFunc) PassRef() (ref *C.ALooper_callbackFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if looperCallbackFunc7E6B484CFunc == nil {
		looperCallbackFunc7E6B484CFunc = x
	}
	return (*C.ALooper_callbackFunc)(C.ALooper_callbackFunc_7e6b484c), nil
}

// PassValue returns a value.
func (x LooperCallbackFunc) PassValue() (ref C.ALooper_callbackFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if looperCallbackFunc7E6B484CFunc == nil {
		looperCallbackFunc7E6B484CFunc = x
	}
	return (C.ALooper_callbackFunc)(C.ALooper_callbackFunc_7e6b484c), nil
}

//export looperCallbackFunc7E6B484C
func looperCallbackFunc7E6B484C(cfd C.int, cevents C.int, cdata unsafe.Pointer) C.int {
	if looperCallbackFunc7E6B484CFunc != nil {
		fd7e6b484c := (int32)(cfd)
		events7e6b484c := (int32)(cevents)
		data7e6b484c := (unsafe.Pointer)(unsafe.Pointer(cdata))
		ret7e6b484c := looperCallbackFunc7E6B484CFunc(fd7e6b484c, events7e6b484c, data7e6b484c)
		ret, _ := (C.int)(ret7e6b484c), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var looperCallbackFunc7E6B484CFunc LooperCallbackFunc

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocNativeActivityMemory allocates memory for type C.ANativeActivity in C.
// The caller is responsible for freeing the this memory via C.free.
func allocNativeActivityMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfNativeActivityValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfNativeActivityValue = unsafe.Sizeof([1]C.ANativeActivity{})

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

type stringHeader struct {
	Data uintptr
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len))
}

// Ref returns a reference.
func (x *NativeActivity) Ref() *C.ANativeActivity {
	if x == nil {
		return nil
	}
	return x.ref2cc295bf
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *NativeActivity) Free() {
	if x != nil && x.allocs2cc295bf != nil {
		x.allocs2cc295bf.(*cgoAllocMap).Free()
		x.ref2cc295bf = nil
	}
}

// NewNativeActivityRef initialises a new struct holding the reference to the originaitng C struct.
func NewNativeActivityRef(ref interface{}) *NativeActivity {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(NativeActivity)
	obj.ref2cc295bf = (*C.ANativeActivity)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *NativeActivity) PassRef() (*C.ANativeActivity, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2cc295bf != nil {
		return x.ref2cc295bf, nil
	}
	mem2cc295bf := allocNativeActivityMemory(1)
	ref2cc295bf := (*C.ANativeActivity)(mem2cc295bf)
	allocs2cc295bf := new(cgoAllocMap)
	var ccallbacks_allocs *cgoAllocMap
	ref2cc295bf.callbacks, ccallbacks_allocs = *(**C.struct_ANativeActivityCallbacks)(unsafe.Pointer(&x.Callbacks)), cgoAllocsUnknown
	allocs2cc295bf.Borrow(ccallbacks_allocs)

	var cvm_allocs *cgoAllocMap
	ref2cc295bf.vm, cvm_allocs = *(**C.JavaVM)(unsafe.Pointer(&x.Vm)), cgoAllocsUnknown
	allocs2cc295bf.Borrow(cvm_allocs)

	var cenv_allocs *cgoAllocMap
	ref2cc295bf.env, cenv_allocs = *(**C.JNIEnv)(unsafe.Pointer(&x.Env)), cgoAllocsUnknown
	allocs2cc295bf.Borrow(cenv_allocs)

	var cclazz_allocs *cgoAllocMap
	ref2cc295bf.clazz, cclazz_allocs = *(*C.jobject)(unsafe.Pointer(&x.Clazz)), cgoAllocsUnknown
	allocs2cc295bf.Borrow(cclazz_allocs)

	var cinternalDataPath_allocs *cgoAllocMap
	ref2cc295bf.internalDataPath, cinternalDataPath_allocs = unpackPCharString(x.InternalDataPath)
	allocs2cc295bf.Borrow(cinternalDataPath_allocs)

	var cexternalDataPath_allocs *cgoAllocMap
	ref2cc295bf.externalDataPath, cexternalDataPath_allocs = unpackPCharString(x.ExternalDataPath)
	allocs2cc295bf.Borrow(cexternalDataPath_allocs)

	var csdkVersion_allocs *cgoAllocMap
	ref2cc295bf.sdkVersion, csdkVersion_allocs = (C.int32_t)(x.SdkVersion), cgoAllocsUnknown
	allocs2cc295bf.Borrow(csdkVersion_allocs)

	var cinstance_allocs *cgoAllocMap
	ref2cc295bf.instance, cinstance_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Instance)), cgoAllocsUnknown
	allocs2cc295bf.Borrow(cinstance_allocs)

	var cassetManager_allocs *cgoAllocMap
	ref2cc295bf.assetManager, cassetManager_allocs = *(**C.AAssetManager)(unsafe.Pointer(&x.AssetManager)), cgoAllocsUnknown
	allocs2cc295bf.Borrow(cassetManager_allocs)

	var cobbPath_allocs *cgoAllocMap
	ref2cc295bf.obbPath, cobbPath_allocs = unpackPCharString(x.ObbPath)
	allocs2cc295bf.Borrow(cobbPath_allocs)

	x.ref2cc295bf = ref2cc295bf
	x.allocs2cc295bf = allocs2cc295bf
	return ref2cc295bf, allocs2cc295bf

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x NativeActivity) PassValue() (C.ANativeActivity, *cgoAllocMap) {
	if x.ref2cc295bf != nil {
		return *x.ref2cc295bf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *NativeActivity) Deref() {
	if x.ref2cc295bf == nil {
		return
	}
	x.Callbacks = (*NativeActivityCallbacks)(unsafe.Pointer(x.ref2cc295bf.callbacks))
	x.Vm = (*JavaVM)(unsafe.Pointer(x.ref2cc295bf.vm))
	x.Env = (*JNIEnv)(unsafe.Pointer(x.ref2cc295bf.env))
	x.Clazz = (*Jobject)(unsafe.Pointer(x.ref2cc295bf.clazz))
	x.InternalDataPath = packPCharString(x.ref2cc295bf.internalDataPath)
	x.ExternalDataPath = packPCharString(x.ref2cc295bf.externalDataPath)
	x.SdkVersion = (int32)(x.ref2cc295bf.sdkVersion)
	x.Instance = (unsafe.Pointer)(unsafe.Pointer(x.ref2cc295bf.instance))
	x.AssetManager = (*AssetManager)(unsafe.Pointer(x.ref2cc295bf.assetManager))
	x.ObbPath = packPCharString(x.ref2cc295bf.obbPath)
}

// Ref returns a reference.
func (x *NativeActivityCallbacks) Ref() *C.ANativeActivityCallbacks {
	if x == nil {
		return nil
	}
	return (*C.ANativeActivityCallbacks)(unsafe.Pointer(x))
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *NativeActivityCallbacks) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewNativeActivityCallbacksRef initialises a new struct.
func NewNativeActivityCallbacksRef(ref *C.ANativeActivityCallbacks) *NativeActivityCallbacks {
	return (*NativeActivityCallbacks)(unsafe.Pointer(ref))
}

// PassRef returns a reference and creates new object if no refernce yet.
func (x *NativeActivityCallbacks) PassRef() *C.ANativeActivityCallbacks {
	if x == nil {
		x = new(NativeActivityCallbacks)
	}
	return (*C.ANativeActivityCallbacks)(unsafe.Pointer(x))
}

// PassRef returns a reference.
func (x NativeActivityCreateFunc) PassRef() (ref *C.ANativeActivity_createFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if nativeActivityCreateFunc76DCE4Func == nil {
		nativeActivityCreateFunc76DCE4Func = x
	}
	return (*C.ANativeActivity_createFunc)(C.ANativeActivity_createFunc_76dce4), nil
}

//export nativeActivityCreateFunc76DCE4
func nativeActivityCreateFunc76DCE4(cactivity *C.ANativeActivity, csavedState unsafe.Pointer, csavedStateSize C.size_t) {
	if nativeActivityCreateFunc76DCE4Func != nil {
		activity76dce4 := NewNativeActivityRef(cactivity)
		savedState76dce4 := (unsafe.Pointer)(unsafe.Pointer(csavedState))
		savedStateSize76dce4 := (uint32)(csavedStateSize)
		nativeActivityCreateFunc76DCE4Func(activity76dce4, savedState76dce4, savedStateSize76dce4)
	}
	panic("callback func has not been set (race?)")
}

var nativeActivityCreateFunc76DCE4Func NativeActivityCreateFunc

// Ref returns a reference.
func (x *InputEvent) Ref() *C.AInputEvent {
	if x == nil {
		return nil
	}
	return (*C.AInputEvent)(unsafe.Pointer(x))
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *InputEvent) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewInputEventRef initialises a new struct.
func NewInputEventRef(ref *C.AInputEvent) *InputEvent {
	return (*InputEvent)(unsafe.Pointer(ref))
}

// PassRef returns a reference and creates new object if no refernce yet.
func (x *InputEvent) PassRef() *C.AInputEvent {
	if x == nil {
		x = new(InputEvent)
	}
	return (*C.AInputEvent)(unsafe.Pointer(x))
}

// Ref returns a reference.
func (x *InputQueue) Ref() *C.AInputQueue {
	if x == nil {
		return nil
	}
	return (*C.AInputQueue)(unsafe.Pointer(x))
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *InputQueue) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewInputQueueRef initialises a new struct.
func NewInputQueueRef(ref *C.AInputQueue) *InputQueue {
	return (*InputQueue)(unsafe.Pointer(ref))
}

// PassRef returns a reference and creates new object if no refernce yet.
func (x *InputQueue) PassRef() *C.AInputQueue {
	if x == nil {
		x = new(InputQueue)
	}
	return (*C.AInputQueue)(unsafe.Pointer(x))
}

// Ref returns a reference.
func (x *NativeWindow) Ref() *C.ANativeWindow {
	if x == nil {
		return nil
	}
	return (*C.ANativeWindow)(unsafe.Pointer(x))
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *NativeWindow) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewNativeWindowRef initialises a new struct.
func NewNativeWindowRef(ref *C.ANativeWindow) *NativeWindow {
	return (*NativeWindow)(unsafe.Pointer(ref))
}

// PassRef returns a reference and creates new object if no refernce yet.
func (x *NativeWindow) PassRef() *C.ANativeWindow {
	if x == nil {
		x = new(NativeWindow)
	}
	return (*C.ANativeWindow)(unsafe.Pointer(x))
}

// allocNativeWindowBufferMemory allocates memory for type C.ANativeWindow_Buffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocNativeWindowBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfNativeWindowBufferValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfNativeWindowBufferValue = unsafe.Sizeof([1]C.ANativeWindow_Buffer{})

// Ref returns a reference.
func (x *NativeWindowBuffer) Ref() *C.ANativeWindow_Buffer {
	if x == nil {
		return nil
	}
	return x.ref3db2646c
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *NativeWindowBuffer) Free() {
	if x != nil && x.allocs3db2646c != nil {
		x.allocs3db2646c.(*cgoAllocMap).Free()
		x.ref3db2646c = nil
	}
}

// NewNativeWindowBufferRef initialises a new struct holding the reference to the originaitng C struct.
func NewNativeWindowBufferRef(ref interface{}) *NativeWindowBuffer {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(NativeWindowBuffer)
	obj.ref3db2646c = (*C.ANativeWindow_Buffer)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *NativeWindowBuffer) PassRef() (*C.ANativeWindow_Buffer, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3db2646c != nil {
		return x.ref3db2646c, nil
	}
	mem3db2646c := allocNativeWindowBufferMemory(1)
	ref3db2646c := (*C.ANativeWindow_Buffer)(mem3db2646c)
	allocs3db2646c := new(cgoAllocMap)
	var cwidth_allocs *cgoAllocMap
	ref3db2646c.width, cwidth_allocs = (C.int32_t)(x.Width), cgoAllocsUnknown
	allocs3db2646c.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref3db2646c.height, cheight_allocs = (C.int32_t)(x.Height), cgoAllocsUnknown
	allocs3db2646c.Borrow(cheight_allocs)

	var cstride_allocs *cgoAllocMap
	ref3db2646c.stride, cstride_allocs = (C.int32_t)(x.Stride), cgoAllocsUnknown
	allocs3db2646c.Borrow(cstride_allocs)

	var cformat_allocs *cgoAllocMap
	ref3db2646c.format, cformat_allocs = (C.int32_t)(x.Format), cgoAllocsUnknown
	allocs3db2646c.Borrow(cformat_allocs)

	var cbits_allocs *cgoAllocMap
	ref3db2646c.bits, cbits_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Bits)), cgoAllocsUnknown
	allocs3db2646c.Borrow(cbits_allocs)

	var creserved_allocs *cgoAllocMap
	ref3db2646c.reserved, creserved_allocs = *(*[6]C.uint32_t)(unsafe.Pointer(&x.Reserved)), cgoAllocsUnknown
	allocs3db2646c.Borrow(creserved_allocs)

	x.ref3db2646c = ref3db2646c
	x.allocs3db2646c = allocs3db2646c
	return ref3db2646c, allocs3db2646c

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x NativeWindowBuffer) PassValue() (C.ANativeWindow_Buffer, *cgoAllocMap) {
	if x.ref3db2646c != nil {
		return *x.ref3db2646c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *NativeWindowBuffer) Deref() {
	if x.ref3db2646c == nil {
		return
	}
	x.Width = (int32)(x.ref3db2646c.width)
	x.Height = (int32)(x.ref3db2646c.height)
	x.Stride = (int32)(x.ref3db2646c.stride)
	x.Format = (int32)(x.ref3db2646c.format)
	x.Bits = (unsafe.Pointer)(unsafe.Pointer(x.ref3db2646c.bits))
	x.Reserved = *(*[6]uint32)(unsafe.Pointer(&x.ref3db2646c.reserved))
}

// allocRectMemory allocates memory for type C.ARect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRectValue = unsafe.Sizeof([1]C.ARect{})

// Ref returns a reference.
func (x *Rect) Ref() *C.ARect {
	if x == nil {
		return nil
	}
	return x.ref9511c547
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Rect) Free() {
	if x != nil && x.allocs9511c547 != nil {
		x.allocs9511c547.(*cgoAllocMap).Free()
		x.ref9511c547 = nil
	}
}

// NewRectRef initialises a new struct holding the reference to the originaitng C struct.
func NewRectRef(ref interface{}) *Rect {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(Rect)
	obj.ref9511c547 = (*C.ARect)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Rect) PassRef() (*C.ARect, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9511c547 != nil {
		return x.ref9511c547, nil
	}
	mem9511c547 := allocRectMemory(1)
	ref9511c547 := (*C.ARect)(mem9511c547)
	allocs9511c547 := new(cgoAllocMap)
	var cleft_allocs *cgoAllocMap
	ref9511c547.left, cleft_allocs = (C.int32_t)(x.Left), cgoAllocsUnknown
	allocs9511c547.Borrow(cleft_allocs)

	var ctop_allocs *cgoAllocMap
	ref9511c547.top, ctop_allocs = (C.int32_t)(x.Top), cgoAllocsUnknown
	allocs9511c547.Borrow(ctop_allocs)

	var cright_allocs *cgoAllocMap
	ref9511c547.right, cright_allocs = (C.int32_t)(x.Right), cgoAllocsUnknown
	allocs9511c547.Borrow(cright_allocs)

	var cbottom_allocs *cgoAllocMap
	ref9511c547.bottom, cbottom_allocs = (C.int32_t)(x.Bottom), cgoAllocsUnknown
	allocs9511c547.Borrow(cbottom_allocs)

	x.ref9511c547 = ref9511c547
	x.allocs9511c547 = allocs9511c547
	return ref9511c547, allocs9511c547

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x Rect) PassValue() (C.ARect, *cgoAllocMap) {
	if x.ref9511c547 != nil {
		return *x.ref9511c547, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Rect) Deref() {
	if x.ref9511c547 == nil {
		return
	}
	x.Left = (int32)(x.ref9511c547.left)
	x.Top = (int32)(x.ref9511c547.top)
	x.Right = (int32)(x.ref9511c547.right)
	x.Bottom = (int32)(x.ref9511c547.bottom)
}

// Ref returns a reference.
func (x *ObbInfo) Ref() *C.AObbInfo {
	if x == nil {
		return nil
	}
	return (*C.AObbInfo)(unsafe.Pointer(x))
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ObbInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewObbInfoRef initialises a new struct.
func NewObbInfoRef(ref *C.AObbInfo) *ObbInfo {
	return (*ObbInfo)(unsafe.Pointer(ref))
}

// PassRef returns a reference and creates new object if no refernce yet.
func (x *ObbInfo) PassRef() *C.AObbInfo {
	if x == nil {
		x = new(ObbInfo)
	}
	return (*C.AObbInfo)(unsafe.Pointer(x))
}

// Ref returns a reference.
func (x *StorageManager) Ref() *C.AStorageManager {
	if x == nil {
		return nil
	}
	return (*C.AStorageManager)(unsafe.Pointer(x))
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *StorageManager) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStorageManagerRef initialises a new struct.
func NewStorageManagerRef(ref *C.AStorageManager) *StorageManager {
	return (*StorageManager)(unsafe.Pointer(ref))
}

// PassRef returns a reference and creates new object if no refernce yet.
func (x *StorageManager) PassRef() *C.AStorageManager {
	if x == nil {
		x = new(StorageManager)
	}
	return (*C.AStorageManager)(unsafe.Pointer(x))
}

// PassRef returns a reference.
func (x StorageManagerObbCallbackFunc) PassRef() (ref *C.AStorageManager_obbCallbackFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if storageManagerObbCallbackFuncE8B15C3EFunc == nil {
		storageManagerObbCallbackFuncE8B15C3EFunc = x
	}
	return (*C.AStorageManager_obbCallbackFunc)(C.AStorageManager_obbCallbackFunc_e8b15c3e), nil
}

// PassValue returns a value.
func (x StorageManagerObbCallbackFunc) PassValue() (ref C.AStorageManager_obbCallbackFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if storageManagerObbCallbackFuncE8B15C3EFunc == nil {
		storageManagerObbCallbackFuncE8B15C3EFunc = x
	}
	return (C.AStorageManager_obbCallbackFunc)(C.AStorageManager_obbCallbackFunc_e8b15c3e), nil
}

//export storageManagerObbCallbackFuncE8B15C3E
func storageManagerObbCallbackFuncE8B15C3E(cfilename *C.char, cstate C.int32_t, cdata unsafe.Pointer) {
	if storageManagerObbCallbackFuncE8B15C3EFunc != nil {
		filenamee8b15c3e := packPCharString(cfilename)
		statee8b15c3e := (int32)(cstate)
		datae8b15c3e := (unsafe.Pointer)(unsafe.Pointer(cdata))
		storageManagerObbCallbackFuncE8B15C3EFunc(filenamee8b15c3e, statee8b15c3e, datae8b15c3e)
	}
	panic("callback func has not been set (race?)")
}

var storageManagerObbCallbackFuncE8B15C3EFunc StorageManagerObbCallbackFunc

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}
